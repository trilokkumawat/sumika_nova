;!function(){try { var e="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof global?global:"undefined"!=typeof window?window:"undefined"!=typeof self?self:{},n=(new e.Error).stack;n&&((e._debugIds|| (e._debugIds={}))[n]="7590921c-3e01-65e8-b801-1458af7b9e70")}catch(e){}}();
(globalThis.TURBOPACK||(globalThis.TURBOPACK=[])).push(["object"==typeof document?document.currentScript:void 0,202654,(e,t,n)=>{"use strict";var s,r,a=(e,t,n)=>{if(!t.has(e))throw TypeError("Cannot access private method");return n},o={"Content-Type":"application/json"},i=/\/*$/;function c(e){let t=new URLSearchParams;if(e&&"object"==typeof e)for(let[n,s]of Object.entries(e))null!=s&&t.set(n,s);return t.toString()}function l(e){return JSON.stringify(e)}var p=class extends Error{constructor(e,t){super(e),this.response=t}},u=class{constructor(e){this.options=e,((e,t,n)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,void 0)})(this,s)}async getOrganizations(){let{data:e,response:t}=await this.client.get("/v1/organizations",{});if(200!==t.status)throw new p(`Failed to get organizations: ${t.statusText} (${t.status})`,t);return e}async createOrganization(e){let{data:t,response:n}=await this.client.post("/v1/organizations",{body:e});if(201!==n.status)throw await a(this,s,r).call(this,n,"create organization");return t}async getBranchDetails(e){let{data:t,response:n}=await this.client.get("/v1/branches/{branch_id}",{params:{path:{branch_id:e}}});if(200!==n.status)throw await a(this,s,r).call(this,n,"get branch details");return t}async deleteBranch(e){let{response:t}=await this.client.del("/v1/branches/{branch_id}",{params:{path:{branch_id:e}}});if(200!==t.status)throw await a(this,s,r).call(this,t,"delete branch")}async updateBranch(e,t){let{data:n,response:o}=await this.client.patch("/v1/branches/{branch_id}",{params:{path:{branch_id:e}},body:t});if(200!==o.status)throw await a(this,s,r).call(this,o,"update branch");return n}async getProjects(){let{data:e,response:t}=await this.client.get("/v1/projects",{});if(200!==t.status)throw await a(this,s,r).call(this,t,"get projects");return e}async createProject(e){let{data:t,response:n}=await this.client.post("/v1/projects",{body:e});if(201!==n.status)throw await a(this,s,r).call(this,n,"create project");return t}async listFunctions(e){let{data:t,response:n}=await this.client.get("/v1/projects/{ref}/functions",{params:{path:{ref:e}}});if(200!==n.status)throw await a(this,s,r).call(this,n,"list functions");return t}async createFunction(e,t){let{data:n,response:o}=await this.client.post("/v1/projects/{ref}/functions",{params:{path:{ref:e}},body:t});if(201!==o.status)throw await a(this,s,r).call(this,o,"create function");return n}async getFunction(e,t){let{data:n,response:o}=await this.client.get("/v1/projects/{ref}/functions/{function_slug}",{params:{path:{ref:e,function_slug:t}}});if(200!==o.status)throw await a(this,s,r).call(this,o,"get function");return n}async updateFunction(e,t,n){let{data:o,response:i}=await this.client.patch("/v1/projects/{ref}/functions/{function_slug}",{params:{path:{ref:e,function_slug:t}},body:n});if(200!==i.status)throw await a(this,s,r).call(this,i,"update function");return o}async deleteFunction(e,t){let{response:n}=await this.client.del("/v1/projects/{ref}/functions/{function_slug}",{params:{path:{ref:e,function_slug:t}}});if(200!==n.status)throw await a(this,s,r).call(this,n,"delete function")}async getFunctionBody(e,t){let{data:n,response:o}=await this.client.get("/v1/projects/{ref}/functions/{function_slug}/body",{params:{path:{ref:e,function_slug:t}}});if(200!==o.status)throw await a(this,s,r).call(this,o,"get function body");return n}async getProjectApiKeys(e){let{data:t,response:n}=await this.client.get("/v1/projects/{ref}/api-keys",{params:{path:{ref:e}}});if(200!==n.status)throw await a(this,s,r).call(this,n,"get project api keys");return t}async getCustomHostnameConfig(e){let{data:t,response:n}=await this.client.get("/v1/projects/{ref}/custom-hostname",{params:{path:{ref:e}}});if(200!==n.status)throw await a(this,s,r).call(this,n,"get custom hostname");return t}async removeCustomHostnameConfig(e){let{response:t}=await this.client.del("/v1/projects/{ref}/custom-hostname",{params:{path:{ref:e}}});if(200!==t.status)throw await a(this,s,r).call(this,t,"remove custom hostname config")}async createCustomHostnameConfig(e,t){let{data:n,response:o}=await this.client.post("/v1/projects/{ref}/custom-hostname/initialize",{params:{path:{ref:e}},body:t});if(201!==o.status)throw await a(this,s,r).call(this,o,"create custom hostname config");return n}async reverifyCustomHostnameConfig(e){let{data:t,response:n}=await this.client.post("/v1/projects/{ref}/custom-hostname/reverify",{params:{path:{ref:e}}});if(200!==n.status)throw await a(this,s,r).call(this,n,"reverify custom hostname config");return t}async activateCustomHostnameConfig(e){let{data:t,response:n}=await this.client.post("/v1/projects/{ref}/custom-hostname/activate",{params:{path:{ref:e}}});if(200!==n.status)throw await a(this,s,r).call(this,n,"activate custom hostname config");return t}async getNetworkBans(e){let{data:t,response:n}=await this.client.post("/v1/projects/{ref}/network-bans/retrieve",{params:{path:{ref:e}}});if(200!==n.status)throw await a(this,s,r).call(this,n,"get network bans");return t}async removeNetworkBan(e,t){let{response:n}=await this.client.del("/v1/projects/{ref}/network-bans",{params:{path:{ref:e}},body:t});if(200!==n.status)throw await a(this,s,r).call(this,n,"remove network ban")}async getNetworkRestrictions(e){let{data:t,response:n}=await this.client.get("/v1/projects/{ref}/network-restrictions",{params:{path:{ref:e}}});if(200!==n.status)throw await a(this,s,r).call(this,n,"get network restrictions");return t}async applyNetworkRestrictions(e,t){let{data:n,response:o}=await this.client.post("/v1/projects/{ref}/network-restrictions/apply",{params:{path:{ref:e}},body:t});if(200!==o.status)throw await a(this,s,r).call(this,o,"apply network restrictions");return n}async getPgsodiumConfig(e){let{data:t,response:n}=await this.client.get("/v1/projects/{ref}/pgsodium",{params:{path:{ref:e}}});if(200!==n.status)throw await a(this,s,r).call(this,n,"get pg sodium config");return t}async updatePgSodiumConfig(e,t){let{data:n,response:o}=await this.client.put("/v1/projects/{ref}/pgsodium",{params:{path:{ref:e}},body:t});if(200!==o.status)throw await a(this,s,r).call(this,o,"update pg sodium config");return n}async getPostgRESTConfig(e){let{data:t,response:n}=await this.client.get("/v1/projects/{ref}/postgrest",{params:{path:{ref:e}}});if(200!==n.status)throw await a(this,s,r).call(this,n,"get postgrest config");return t}async updatePostgRESTConfig(e,t){let{data:n,response:o}=await this.client.patch("/v1/projects/{ref}/postgrest",{params:{path:{ref:e}},body:t});if(200!==o.status)throw await a(this,s,r).call(this,o,"update postgrest config");return n}async runQuery(e,t){let{data:n,response:o}=await this.client.post("/v1/projects/{ref}/database/query",{params:{path:{ref:e}},body:{query:t}});if(201!==o.status)throw await a(this,s,r).call(this,o,"run query");return n}async enableWebhooks(e){let{data:t,response:n}=await this.client.post("/v1/projects/{ref}/database/webhooks/enable",{params:{path:{ref:e}}});if(201!==n.status)throw await a(this,s,r).call(this,n,"enable webhooks")}async getSecrets(e){let{data:t,response:n}=await this.client.get("/v1/projects/{ref}/secrets",{params:{path:{ref:e}}});if(200!==n.status)throw await a(this,s,r).call(this,n,"get secrets");return t}async createSecrets(e,t){let{response:n}=await this.client.post("/v1/projects/{ref}/secrets",{params:{path:{ref:e}},body:t});if(201!==n.status)throw await a(this,s,r).call(this,n,"create secrets")}async deleteSecrets(e,t){let{data:n,response:o}=await this.client.del("/v1/projects/{ref}/secrets",{params:{path:{ref:e}},body:t});if(200!==o.status)throw await a(this,s,r).call(this,o,"delete secrets");return n}async getSSLEnforcementConfig(e){let{data:t,response:n}=await this.client.get("/v1/projects/{ref}/ssl-enforcement",{params:{path:{ref:e}}});if(200!==n.status)throw await a(this,s,r).call(this,n,"get ssl enforcement config");return t}async updateSSLEnforcementConfig(e,t){let{data:n,response:o}=await this.client.put("/v1/projects/{ref}/ssl-enforcement",{params:{path:{ref:e}},body:t});if(200!==o.status)throw await a(this,s,r).call(this,o,"update ssl enforcement config");return n}async getTypescriptTypes(e){let{data:t,response:n}=await this.client.get("/v1/projects/{ref}/types/typescript",{params:{path:{ref:e}}});if(200!==n.status)throw await a(this,s,r).call(this,n,"get typescript types");return t}async getVanitySubdomainConfig(e){let{data:t,response:n}=await this.client.get("/v1/projects/{ref}/vanity-subdomain",{params:{path:{ref:e}}});if(200!==n.status)throw await a(this,s,r).call(this,n,"get vanity subdomain config");return t}async removeVanitySubdomainConfig(e){let{response:t}=await this.client.del("/v1/projects/{ref}/vanity-subdomain",{params:{path:{ref:e}}});if(200!==t.status)throw await a(this,s,r).call(this,t,"remove vanity subdomain config")}async checkVanitySubdomainAvailability(e,t){let{data:n,response:o}=await this.client.post("/v1/projects/{ref}/vanity-subdomain/check-availability",{params:{path:{ref:e}},body:{vanity_subdomain:t}});if(200!==o.status)throw await a(this,s,r).call(this,o,"check vanity subdomain availability");return void 0!==n&&n.available}async activateVanitySubdomainPlease(e,t){let{response:n,data:o}=await this.client.post("/v1/projects/{ref}/vanity-subdomain/activate",{params:{path:{ref:e}},body:{vanity_subdomain:t}});if(200!==n.status)throw await a(this,s,r).call(this,n,"activate vanity subdomain");return o?.custom_domain}async upgradeProject(e,t){let{response:n}=await this.client.post("/v1/projects/{ref}/upgrade",{params:{path:{ref:e}},body:{target_version:t}});if(200!==n.status)throw await a(this,s,r).call(this,n,"upgrade project")}async getUpgradeEligibility(e){let{data:t,response:n}=await this.client.get("/v1/projects/{ref}/upgrade/eligibility",{params:{path:{ref:e}}});if(200!==n.status)throw await a(this,s,r).call(this,n,"get upgrade eligibility");return t}async getUpgradeStatus(e){let{data:t,response:n}=await this.client.get("/v1/projects/{ref}/upgrade/status",{params:{path:{ref:e}}});if(200!==n.status)throw await a(this,s,r).call(this,n,"get upgrade status");return t}async getReadOnlyModeStatus(e){let{data:t,response:n}=await this.client.get("/v1/projects/{ref}/readonly",{params:{path:{ref:e}}});if(200!==n.status)throw await a(this,s,r).call(this,n,"get readonly mode status");return t}async temporarilyDisableReadonlyMode(e){let{response:t}=await this.client.post("/v1/projects/{ref}/readonly/temporary-disable",{params:{path:{ref:e}}});if(200!==t.status)throw await a(this,s,r).call(this,t,"temporarily disable readonly mode")}async getPGConfig(e){let{data:t,response:n}=await this.client.get("/v1/projects/{ref}/config/database/postgres",{params:{path:{ref:e}}});if(200!==n.status)throw await a(this,s,r).call(this,n,"get PG config");return t}async updatePGConfig(e,t){let{data:n,response:o}=await this.client.put("/v1/projects/{ref}/config/database/postgres",{params:{path:{ref:e}},body:t});if(200!==o.status)throw await a(this,s,r).call(this,o,"update PG config");return n}async getPgBouncerConfig(e){let{data:t,response:n}=await this.client.get("/v1/projects/{ref}/config/database/pgbouncer",{params:{path:{ref:e}}});if(200!==n.status)throw await a(this,s,r).call(this,n,"get Pgbouncer config");return t}async getProjectAuthConfig(e){let{data:t,response:n}=await this.client.get("/v1/projects/{ref}/config/auth",{params:{path:{ref:e}}});if(200!==n.status)throw await a(this,s,r).call(this,n,"get project auth config");return t}async updateProjectAuthConfig(e,t){let{data:n,response:o}=await this.client.patch("/v1/projects/{ref}/config/auth",{params:{path:{ref:e}},body:t});if(200!==o.status)throw await a(this,s,r).call(this,o,"update project auth config");return n}async getSSOProviders(e){let{data:t,response:n}=await this.client.get("/v1/projects/{ref}/config/auth/sso/providers",{params:{path:{ref:e}}});if(200!==n.status)throw await a(this,s,r).call(this,n,"get SSO providers");return t}async createSSOProvider(e,t){let{data:n,response:o}=await this.client.post("/v1/projects/{ref}/config/auth/sso/providers",{params:{path:{ref:e}},body:t});if(201!==o.status)throw await a(this,s,r).call(this,o,"create SSO provider");return n}async getSSOProvider(e,t){let{data:n,response:o}=await this.client.get("/v1/projects/{ref}/config/auth/sso/providers/{provider_id}",{params:{path:{ref:e,provider_id:t}}});if(200!==o.status)throw await a(this,s,r).call(this,o,"get SSO provider");return n}async updateSSOProvider(e,t,n){let{data:o,response:i}=await this.client.put("/v1/projects/{ref}/config/auth/sso/providers/{provider_id}",{params:{path:{ref:e,provider_id:t}},body:n});if(200!==i.status)throw await a(this,s,r).call(this,i,"update SSO provider");return o}async deleteSSOProvider(e,t){let{response:n}=await this.client.del("/v1/projects/{ref}/config/auth/sso/providers/{provider_id}",{params:{path:{ref:e,provider_id:t}}});if(204!==n.status)throw await a(this,s,r).call(this,n,"delete SSO provider")}get client(){return function(e={}){let{fetch:t=globalThis.fetch,querySerializer:n,bodySerializer:s,...r}=e,a=new Headers({...o,...r.headers??{}});async function p(e,o){let{headers:p,body:u,params:h={},parseAs:d="json",querySerializer:g=n??c,bodySerializer:m=s??l,...f}=o||{},w=function(e,t){let n=`${t.baseUrl?t.baseUrl.replace(i,""):""}${e}`;if(t.params.path)for(let[e,s]of Object.entries(t.params.path))n=n.replace(`{${e}}`,encodeURIComponent(String(s)));if(t.params.query){let e=t.querySerializer(t.params.query);e&&(n+=`?${e}`)}return n}(e,{baseUrl:r.baseUrl,params:h,querySerializer:g}),y=new Headers(a);for(let[e,t]of new Headers(p).entries())null==t?y.delete(e):y.set(e,t);let S={redirect:"follow",...r,...f,headers:y};u&&(S.body=m(u)),S.body instanceof FormData&&y.delete("Content-Type");let E=await t(w,S);if(204===E.status||"0"===E.headers.get("Content-Length"))return E.ok?{data:{},response:E}:{error:{},response:E};if(E.ok){let e=E.body;if("stream"!==d){let t=E.clone();e="function"==typeof t[d]?await t[d]():await t.text()}return{data:e,response:E}}let b={};try{b=await E.clone().json()}catch{b=await E.clone().text()}return{error:b,response:E}}return{get:async(e,t)=>p(e,{...t,method:"GET"}),put:async(e,t)=>p(e,{...t,method:"PUT"}),post:async(e,t)=>p(e,{...t,method:"POST"}),del:async(e,t)=>p(e,{...t,method:"DELETE"}),options:async(e,t)=>p(e,{...t,method:"OPTIONS"}),head:async(e,t)=>p(e,{...t,method:"HEAD"}),patch:async(e,t)=>p(e,{...t,method:"PATCH"}),trace:async(e,t)=>p(e,{...t,method:"TRACE"})}}({baseUrl:this.options.baseUrl||"https://api.supabase.com",headers:{Authorization:`Bearer ${this.options.accessToken}`}})}};async function h(e){try{let t=await e.json();if("object"==typeof t&&null!==t&&"message"in t&&"string"==typeof t.message)return{message:t.message}}catch(e){return}}s=new WeakSet,r=async function(e,t){let n=await h(e);return new p(`Failed to ${t}: ${e.statusText} (${e.status})${n?`: ${n.message}`:""}`,e)},n.SupabaseManagementAPI=u,n.SupabaseManagementAPIError=p,n.isSupabaseError=function(e){return e instanceof p}},850264,465684,e=>{"use strict";var t=e.i(869176),n="1.0.19",s=e.i(202654),r="import { StripeSync, runMigrations, VERSION } from 'npm:stripe-experiment-sync'\nimport postgres from 'npm:postgres'\n\n// Get management API base URL from environment variable (for testing against localhost/staging)\n// Caller should provide full URL with protocol (e.g., http://localhost:54323 or https://api.supabase.com)\nconst MGMT_API_BASE_RAW = Deno.env.get('MANAGEMENT_API_URL') || 'https://api.supabase.com'\nconst MGMT_API_BASE = MGMT_API_BASE_RAW.match(/^https?:\\/\\//)\n  ? MGMT_API_BASE_RAW\n  : `https://${MGMT_API_BASE_RAW}`\n\n// Helper to validate accessToken against Management API\nasync function validateAccessToken(projectRef: string, accessToken: string): Promise<boolean> {\n  // Try to fetch project details using the access token\n  // This validates that the token is valid for the management API\n  const url = `${MGMT_API_BASE}/v1/projects/${projectRef}`\n  const response = await fetch(url, {\n    method: 'GET',\n    headers: {\n      Authorization: `Bearer ${accessToken}`,\n      'Content-Type': 'application/json',\n    },\n  })\n\n  // If we can successfully get the project, the token is valid\n  return response.ok\n}\n\n// Helper to delete edge function via Management API\nasync function deleteEdgeFunction(\n  projectRef: string,\n  functionSlug: string,\n  accessToken: string\n): Promise<void> {\n  const url = `${MGMT_API_BASE}/v1/projects/${projectRef}/functions/${functionSlug}`\n  const response = await fetch(url, {\n    method: 'DELETE',\n    headers: {\n      Authorization: `Bearer ${accessToken}`,\n      'Content-Type': 'application/json',\n    },\n  })\n\n  if (!response.ok && response.status !== 404) {\n    const text = await response.text()\n    throw new Error(`Failed to delete function ${functionSlug}: ${response.status} ${text}`)\n  }\n}\n\n// Helper to delete secrets via Management API\nasync function deleteSecret(\n  projectRef: string,\n  secretName: string,\n  accessToken: string\n): Promise<void> {\n  const url = `${MGMT_API_BASE}/v1/projects/${projectRef}/secrets`\n  const response = await fetch(url, {\n    method: 'DELETE',\n    headers: {\n      Authorization: `Bearer ${accessToken}`,\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify([secretName]),\n  })\n\n  if (!response.ok && response.status !== 404) {\n    const text = await response.text()\n    console.warn(`Failed to delete secret ${secretName}: ${response.status} ${text}`)\n  }\n}\n\nDeno.serve(async (req) => {\n  // Extract project ref from SUPABASE_URL (format: https://{projectRef}.{base})\n  const supabaseUrl = Deno.env.get('SUPABASE_URL')\n  if (!supabaseUrl) {\n    return new Response(JSON.stringify({ error: 'SUPABASE_URL not set' }), {\n      status: 500,\n      headers: { 'Content-Type': 'application/json' },\n    })\n  }\n  const projectRef = new URL(supabaseUrl).hostname.split('.')[0]\n\n  // Validate access token for all requests\n  const authHeader = req.headers.get('Authorization')\n  if (!authHeader?.startsWith('Bearer ')) {\n    return new Response('Unauthorized', { status: 401 })\n  }\n\n  const accessToken = authHeader.substring(7) // Remove 'Bearer '\n  const isValid = await validateAccessToken(projectRef, accessToken)\n  if (!isValid) {\n    return new Response('Forbidden: Invalid access token for this project', { status: 403 })\n  }\n\n  // Handle GET requests for status\n  if (req.method === 'GET') {\n    const rawDbUrl = Deno.env.get('SUPABASE_DB_URL')\n    if (!rawDbUrl) {\n      return new Response(JSON.stringify({ error: 'SUPABASE_DB_URL not set' }), {\n        status: 500,\n        headers: { 'Content-Type': 'application/json' },\n      })\n    }\n\n    const dbUrl = rawDbUrl.replace(/[?&]sslmode=[^&]*/g, '').replace(/[?&]$/, '')\n    let sql\n\n    try {\n      sql = postgres(dbUrl, { max: 1, prepare: false })\n\n      // Query installation status from schema comment\n      const commentResult = await sql`\n        SELECT obj_description(oid, 'pg_namespace') as comment\n        FROM pg_namespace\n        WHERE nspname = 'stripe'\n      `\n\n      const comment = commentResult[0]?.comment || null\n      let installationStatus = 'not_installed'\n\n      if (comment && comment.includes('stripe-sync')) {\n        // Parse installation status from comment\n        if (comment.includes('installation:started')) {\n          installationStatus = 'installing'\n        } else if (comment.includes('installation:error')) {\n          installationStatus = 'error'\n        } else if (comment.includes('installed')) {\n          installationStatus = 'installed'\n        }\n      }\n\n      // Query sync runs (only if schema exists)\n      let syncStatus = []\n      if (comment) {\n        try {\n          syncStatus = await sql`\n            SELECT DISTINCT ON (account_id)\n              account_id, started_at, closed_at, status, error_message,\n              total_processed, total_objects, complete_count, error_count,\n              running_count, pending_count, triggered_by, max_concurrent\n            FROM stripe.sync_runs\n            ORDER BY account_id, started_at DESC\n          `\n        } catch (err) {\n          // Ignore errors if sync_runs view doesn't exist yet\n          console.warn('sync_runs query failed (may not exist yet):', err)\n        }\n      }\n\n      return new Response(\n        JSON.stringify({\n          package_version: VERSION,\n          installation_status: installationStatus,\n          sync_status: syncStatus,\n        }),\n        {\n          status: 200,\n          headers: {\n            'Content-Type': 'application/json',\n            'Cache-Control': 'no-cache, no-store, must-revalidate',\n          },\n        }\n      )\n    } catch (error) {\n      console.error('Status query error:', error)\n      return new Response(\n        JSON.stringify({\n          error: error.message,\n          package_version: VERSION,\n          installation_status: 'not_installed',\n        }),\n        {\n          status: 500,\n          headers: { 'Content-Type': 'application/json' },\n        }\n      )\n    } finally {\n      if (sql) await sql.end()\n    }\n  }\n\n  // Handle DELETE requests for uninstall\n  if (req.method === 'DELETE') {\n    let stripeSync = null\n    try {\n      // Get and validate database URL\n      const rawDbUrl = Deno.env.get('SUPABASE_DB_URL')\n      if (!rawDbUrl) {\n        throw new Error('SUPABASE_DB_URL environment variable is not set')\n      }\n      // Remove sslmode from connection string (not supported by pg in Deno)\n      const dbUrl = rawDbUrl.replace(/[?&]sslmode=[^&]*/g, '').replace(/[?&]$/, '')\n\n      // Stripe key is required for uninstall to delete webhooks\n      const stripeKey = Deno.env.get('STRIPE_SECRET_KEY')\n      if (!stripeKey) {\n        throw new Error('STRIPE_SECRET_KEY environment variable is required for uninstall')\n      }\n\n      // Step 1: Delete Stripe webhooks and clean up database\n      stripeSync = new StripeSync({\n        poolConfig: { connectionString: dbUrl, max: 2 },\n        stripeSecretKey: stripeKey,\n      })\n\n      // Delete all managed webhooks\n      const webhooks = await stripeSync.listManagedWebhooks()\n      for (const webhook of webhooks) {\n        try {\n          await stripeSync.deleteManagedWebhook(webhook.id)\n          console.log(`Deleted webhook: ${webhook.id}`)\n        } catch (err) {\n          console.warn(`Could not delete webhook ${webhook.id}:`, err)\n        }\n      }\n\n      // Unschedule pg_cron job\n      try {\n        await stripeSync.postgresClient.query(`\n          DO $$\n          BEGIN\n            IF EXISTS (SELECT 1 FROM cron.job WHERE jobname = 'stripe-sync-worker') THEN\n              PERFORM cron.unschedule('stripe-sync-worker');\n            END IF;\n          END $$;\n        `)\n      } catch (err) {\n        console.warn('Could not unschedule pg_cron job:', err)\n      }\n\n      // Delete vault secret\n      try {\n        await stripeSync.postgresClient.query(`\n          DELETE FROM vault.secrets\n          WHERE name = 'stripe_sync_worker_secret'\n        `)\n      } catch (err) {\n        console.warn('Could not delete vault secret:', err)\n      }\n\n      // Terminate connections holding locks on stripe schema\n      try {\n        await stripeSync.postgresClient.query(`\n          SELECT pg_terminate_backend(pid)\n          FROM pg_locks l\n          JOIN pg_class c ON l.relation = c.oid\n          JOIN pg_namespace n ON c.relnamespace = n.oid\n          WHERE n.nspname = 'stripe'\n            AND l.pid != pg_backend_pid()\n        `)\n      } catch (err) {\n        console.warn('Could not terminate connections:', err)\n      }\n\n      // Drop schema with retry\n      let dropAttempts = 0\n      const maxAttempts = 3\n      while (dropAttempts < maxAttempts) {\n        try {\n          await stripeSync.postgresClient.query('DROP SCHEMA IF EXISTS stripe CASCADE')\n          break // Success, exit loop\n        } catch (err) {\n          dropAttempts++\n          if (dropAttempts >= maxAttempts) {\n            throw new Error(\n              `Failed to drop schema after ${maxAttempts} attempts. ` +\n                `There may be active connections or locks on the stripe schema. ` +\n                `Error: ${err.message}`\n            )\n          }\n          // Wait 1 second before retrying\n          await new Promise((resolve) => setTimeout(resolve, 1000))\n        }\n      }\n\n      await stripeSync.postgresClient.pool.end()\n\n      // Step 2: Delete Supabase secrets\n      try {\n        await deleteSecret(projectRef, 'STRIPE_SECRET_KEY', accessToken)\n      } catch (err) {\n        console.warn('Could not delete STRIPE_SECRET_KEY secret:', err)\n      }\n\n      // Step 3: Delete Edge Functions\n      try {\n        await deleteEdgeFunction(projectRef, 'stripe-setup', accessToken)\n      } catch (err) {\n        console.warn('Could not delete stripe-setup function:', err)\n      }\n\n      try {\n        await deleteEdgeFunction(projectRef, 'stripe-webhook', accessToken)\n      } catch (err) {\n        console.warn('Could not delete stripe-webhook function:', err)\n      }\n\n      try {\n        await deleteEdgeFunction(projectRef, 'stripe-worker', accessToken)\n      } catch (err) {\n        console.warn('Could not delete stripe-worker function:', err)\n      }\n\n      return new Response(\n        JSON.stringify({\n          success: true,\n          message: 'Uninstall complete',\n        }),\n        {\n          status: 200,\n          headers: { 'Content-Type': 'application/json' },\n        }\n      )\n    } catch (error) {\n      console.error('Uninstall error:', error)\n      // Cleanup on error\n      if (stripeSync) {\n        try {\n          await stripeSync.postgresClient.pool.end()\n        } catch (cleanupErr) {\n          console.warn('Cleanup failed:', cleanupErr)\n        }\n      }\n      return new Response(JSON.stringify({ success: false, error: error.message }), {\n        status: 500,\n        headers: { 'Content-Type': 'application/json' },\n      })\n    }\n  }\n\n  // Handle POST requests for install\n  if (req.method !== 'POST') {\n    return new Response('Method not allowed', { status: 405 })\n  }\n\n  let stripeSync = null\n  try {\n    // Get and validate database URL\n    const rawDbUrl = Deno.env.get('SUPABASE_DB_URL')\n    if (!rawDbUrl) {\n      throw new Error('SUPABASE_DB_URL environment variable is not set')\n    }\n    // Remove sslmode from connection string (not supported by pg in Deno)\n    const dbUrl = rawDbUrl.replace(/[?&]sslmode=[^&]*/g, '').replace(/[?&]$/, '')\n\n    await runMigrations({ databaseUrl: dbUrl })\n\n    stripeSync = new StripeSync({\n      poolConfig: { connectionString: dbUrl, max: 2 }, // Need 2 for advisory lock + queries\n      stripeSecretKey: Deno.env.get('STRIPE_SECRET_KEY'),\n    })\n\n    // Release any stale advisory locks from previous timeouts\n    await stripeSync.postgresClient.query('SELECT pg_advisory_unlock_all()')\n\n    // Construct webhook URL from SUPABASE_URL (available in all Edge Functions)\n    const supabaseUrl = Deno.env.get('SUPABASE_URL')\n    if (!supabaseUrl) {\n      throw new Error('SUPABASE_URL environment variable is not set')\n    }\n    const webhookUrl = supabaseUrl + '/functions/v1/stripe-webhook'\n\n    const webhook = await stripeSync.findOrCreateManagedWebhook(webhookUrl)\n\n    await stripeSync.postgresClient.pool.end()\n\n    return new Response(\n      JSON.stringify({\n        success: true,\n        message: 'Setup complete',\n        webhookId: webhook.id,\n      }),\n      {\n        status: 200,\n        headers: { 'Content-Type': 'application/json' },\n      }\n    )\n  } catch (error) {\n    console.error('Setup error:', error)\n    // Cleanup on error\n    if (stripeSync) {\n      try {\n        await stripeSync.postgresClient.query('SELECT pg_advisory_unlock_all()')\n        await stripeSync.postgresClient.pool.end()\n      } catch (cleanupErr) {\n        console.warn('Cleanup failed:', cleanupErr)\n      }\n    }\n    return new Response(JSON.stringify({ success: false, error: error.message }), {\n      status: 500,\n      headers: { 'Content-Type': 'application/json' },\n    })\n  }\n})\n",a="import { StripeSync } from 'npm:stripe-experiment-sync'\n\nDeno.serve(async (req) => {\n  if (req.method !== 'POST') {\n    return new Response('Method not allowed', { status: 405 })\n  }\n\n  const sig = req.headers.get('stripe-signature')\n  if (!sig) {\n    return new Response('Missing stripe-signature header', { status: 400 })\n  }\n\n  const rawDbUrl = Deno.env.get('SUPABASE_DB_URL')\n  if (!rawDbUrl) {\n    return new Response(JSON.stringify({ error: 'SUPABASE_DB_URL not set' }), { status: 500 })\n  }\n  const dbUrl = rawDbUrl.replace(/[?&]sslmode=[^&]*/g, '').replace(/[?&]$/, '')\n\n  const stripeSync = new StripeSync({\n    poolConfig: { connectionString: dbUrl, max: 1 },\n    stripeSecretKey: Deno.env.get('STRIPE_SECRET_KEY')!,\n  })\n\n  try {\n    const rawBody = new Uint8Array(await req.arrayBuffer())\n    await stripeSync.processWebhook(rawBody, sig)\n    return new Response(JSON.stringify({ received: true }), {\n      status: 200,\n      headers: { 'Content-Type': 'application/json' },\n    })\n  } catch (error) {\n    console.error('Webhook processing error:', error)\n    const isSignatureError =\n      error.message?.includes('signature') || error.type === 'StripeSignatureVerificationError'\n    const status = isSignatureError ? 400 : 500\n    return new Response(JSON.stringify({ error: error.message }), {\n      status,\n      headers: { 'Content-Type': 'application/json' },\n    })\n  } finally {\n    await stripeSync.postgresClient.pool.end()\n  }\n})\n",o="/**\n * Stripe Sync Worker\n *\n * Triggered by pg_cron at a configurable interval (default: 60 seconds). Uses pgmq for durable work queue.\n *\n * Flow:\n * 1. Read batch of messages from pgmq (qty=10, vt=60s)\n * 2. If queue empty: enqueue all objects (continuous sync)\n * 3. Process messages in parallel (Promise.all):\n *    - processNext(object)\n *    - Delete message on success\n *    - Re-enqueue if hasMore\n * 4. Return results summary\n *\n * Concurrency:\n * - Multiple workers can run concurrently via overlapping pg_cron triggers.\n * - Each worker processes its batch of messages in parallel (Promise.all).\n * - pgmq visibility timeout prevents duplicate message reads across workers.\n * - processNext() is idempotent (uses internal cursor tracking), so duplicate\n *   processing on timeout/crash is safe.\n */\n\nimport { StripeSync } from 'npm:stripe-experiment-sync'\nimport postgres from 'npm:postgres'\n\nconst QUEUE_NAME = 'stripe_sync_work'\nconst VISIBILITY_TIMEOUT = 60 // seconds\nconst BATCH_SIZE = 10\n\nDeno.serve(async (req) => {\n  const authHeader = req.headers.get('Authorization')\n  if (!authHeader?.startsWith('Bearer ')) {\n    return new Response('Unauthorized', { status: 401 })\n  }\n\n  const token = authHeader.substring(7) // Remove 'Bearer '\n\n  const rawDbUrl = Deno.env.get('SUPABASE_DB_URL')\n  if (!rawDbUrl) {\n    return new Response(JSON.stringify({ error: 'SUPABASE_DB_URL not set' }), { status: 500 })\n  }\n  const dbUrl = rawDbUrl.replace(/[?&]sslmode=[^&]*/g, '').replace(/[?&]$/, '')\n\n  let sql\n  let stripeSync\n\n  try {\n    sql = postgres(dbUrl, { max: 1, prepare: false })\n  } catch (error) {\n    return new Response(\n      JSON.stringify({\n        error: 'Failed to create postgres connection',\n        details: error.message,\n        stack: error.stack,\n      }),\n      { status: 500, headers: { 'Content-Type': 'application/json' } }\n    )\n  }\n\n  try {\n    // Validate that the token matches the unique worker secret stored in vault\n    const vaultResult = await sql`\n      SELECT decrypted_secret\n      FROM vault.decrypted_secrets\n      WHERE name = 'stripe_sync_worker_secret'\n    `\n\n    if (vaultResult.length === 0) {\n      await sql.end()\n      return new Response('Worker secret not configured in vault', { status: 500 })\n    }\n\n    const storedSecret = vaultResult[0].decrypted_secret\n    if (token !== storedSecret) {\n      await sql.end()\n      return new Response('Forbidden: Invalid worker secret', { status: 403 })\n    }\n\n    stripeSync = new StripeSync({\n      poolConfig: { connectionString: dbUrl, max: 1 },\n      stripeSecretKey: Deno.env.get('STRIPE_SECRET_KEY')!,\n      enableSigma: (Deno.env.get('ENABLE_SIGMA') ?? 'false') === 'true',\n    })\n  } catch (error) {\n    await sql.end()\n    return new Response(\n      JSON.stringify({\n        error: 'Failed to create StripeSync',\n        details: error.message,\n        stack: error.stack,\n      }),\n      { status: 500, headers: { 'Content-Type': 'application/json' } }\n    )\n  }\n\n  try {\n    // Read batch of messages from queue\n    const messages = await sql`\n      SELECT * FROM pgmq.read(${QUEUE_NAME}::text, ${VISIBILITY_TIMEOUT}::int, ${BATCH_SIZE}::int)\n    `\n\n    // If queue empty, enqueue all objects for continuous sync\n    if (messages.length === 0) {\n      // Create sync run to make enqueued work visible (status='pending')\n      const { objects } = await stripeSync.joinOrCreateSyncRun('worker')\n      const msgs = objects.map((object) => JSON.stringify({ object }))\n\n      await sql`\n        SELECT pgmq.send_batch(\n          ${QUEUE_NAME}::text,\n          ${sql.array(msgs)}::jsonb[]\n        )\n      `\n\n      return new Response(JSON.stringify({ enqueued: objects.length, objects }), {\n        status: 200,\n        headers: { 'Content-Type': 'application/json' },\n      })\n    }\n\n    // Process messages in parallel\n    const results = await Promise.all(\n      messages.map(async (msg) => {\n        const { object } = msg.message as { object: string }\n\n        try {\n          const result = await stripeSync.processNext(object)\n\n          // Delete message on success (cast to bigint to disambiguate overloaded function)\n          await sql`SELECT pgmq.delete(${QUEUE_NAME}::text, ${msg.msg_id}::bigint)`\n\n          // Re-enqueue if more pages\n          if (result.hasMore) {\n            await sql`SELECT pgmq.send(${QUEUE_NAME}::text, ${sql.json({ object })}::jsonb)`\n          }\n\n          return { object, ...result }\n        } catch (error) {\n          // Log error but continue to next message\n          // Message will become visible again after visibility timeout\n          console.error(`Error processing ${object}:`, error)\n          return {\n            object,\n            processed: 0,\n            hasMore: false,\n            error: error.message,\n            stack: error.stack,\n          }\n        }\n      })\n    )\n\n    return new Response(JSON.stringify({ results }), {\n      status: 200,\n      headers: { 'Content-Type': 'application/json' },\n    })\n  } catch (error) {\n    console.error('Worker error:', error)\n    return new Response(JSON.stringify({ error: error.message, stack: error.stack }), {\n      status: 500,\n      headers: { 'Content-Type': 'application/json' },\n    })\n  } finally {\n    if (sql) await sql.end()\n    if (stripeSync) await stripeSync.postgresClient.pool.end()\n  }\n})\n",i="stripe-sync",c="installation:started",l="installation:error",p="installed",u=class{api;projectRef;projectBaseUrl;supabaseManagementUrl;accessToken;constructor(e){this.api=new s.SupabaseManagementAPI({accessToken:e.accessToken,baseUrl:e.supabaseManagementUrl}),this.projectRef=e.projectRef,this.projectBaseUrl=e.projectBaseUrl||t.default.env.SUPABASE_BASE_URL||"supabase.co",this.supabaseManagementUrl=e.supabaseManagementUrl,this.accessToken=e.accessToken}async validateProject(){let e=await this.api.getProjects(),t=e?.find(e=>e.id===this.projectRef);if(!t)throw Error(`Project ${this.projectRef} not found or you don't have access`);return{id:t.id,name:t.name,region:t.region}}async deployFunction(e,t,n=!1){let s=await this.api.listFunctions(this.projectRef);s?.some(t=>t.slug===e)?await this.api.updateFunction(this.projectRef,e,{body:t,verify_jwt:n}):await this.api.createFunction(this.projectRef,{slug:e,name:e,body:t,verify_jwt:n})}async setSecrets(e){await this.api.createSecrets(this.projectRef,e)}async runSQL(e){return await this.api.runQuery(this.projectRef,e)}async setupPgCronJob(e=60){let t;if(!Number.isInteger(e)||e<1)throw Error(`Invalid interval: ${e}. Must be a positive integer.`);if(e<60)t=`${e} seconds`;else if(e%60==0){let n=e/60;if(n<60)t=`*/${n} * * * *`;else throw Error(`Invalid interval: ${e}. Intervals >= 3600 seconds (1 hour) are not supported. Use a value between 1-3599 seconds.`)}else throw Error(`Invalid interval: ${e}. Must be either 1-59 seconds or a multiple of 60 (e.g., 60, 120, 180).`);let n=crypto.randomUUID().replace(/'/g,"''"),s=`
      -- Enable extensions
      CREATE EXTENSION IF NOT EXISTS pg_cron;
      CREATE EXTENSION IF NOT EXISTS pg_net;
      CREATE EXTENSION IF NOT EXISTS pgmq;

      -- Create pgmq queue for sync work (idempotent)
      SELECT pgmq.create('stripe_sync_work')
      WHERE NOT EXISTS (
        SELECT 1 FROM pgmq.list_queues() WHERE queue_name = 'stripe_sync_work'
      );

      -- Store unique worker secret in vault for pg_cron to use
      -- Delete existing secret if it exists, then create new one
      DELETE FROM vault.secrets WHERE name = 'stripe_sync_worker_secret';
      SELECT vault.create_secret('${n}', 'stripe_sync_worker_secret');

      -- Delete existing jobs if they exist
      SELECT cron.unschedule('stripe-sync-worker') WHERE EXISTS (
        SELECT 1 FROM cron.job WHERE jobname = 'stripe-sync-worker'
      );
      SELECT cron.unschedule('stripe-sync-scheduler') WHERE EXISTS (
        SELECT 1 FROM cron.job WHERE jobname = 'stripe-sync-scheduler'
      );

      -- Create job to invoke worker at configured interval
      -- Worker reads from pgmq, enqueues objects if empty, and processes sync work
      SELECT cron.schedule(
        'stripe-sync-worker',
        '${t}',
        $$
        SELECT net.http_post(
          url := 'https://${this.projectRef}.${this.projectBaseUrl}/functions/v1/stripe-worker',
          headers := jsonb_build_object(
            'Authorization', 'Bearer ' || (SELECT decrypted_secret FROM vault.decrypted_secrets WHERE name = 'stripe_sync_worker_secret')
          )
        )
        $$
      );
    `;await this.runSQL(s)}getWebhookUrl(){return`https://${this.projectRef}.${this.projectBaseUrl}/functions/v1/stripe-webhook`}async getAnonKey(){let e=await this.api.getProjectApiKeys(this.projectRef),t=e?.find(e=>"anon"===e.name);if(!t)throw Error("Could not find anon API key");return t.api_key}getProjectUrl(){return`https://${this.projectRef}.${this.projectBaseUrl}`}async invokeFunction(e,t){let n=`https://${this.projectRef}.${this.projectBaseUrl}/functions/v1/${e}`,s=await fetch(n,{method:"POST",headers:{Authorization:`Bearer ${t}`,"Content-Type":"application/json"}});if(!s.ok){let e=await s.text();return{success:!1,error:`${s.status}: ${e}`}}let r=await s.json();return!1===r.success?{success:!1,error:r.error}:{success:!0}}async isInstalled(e="stripe"){try{let t=await this.runSQL(`SELECT EXISTS (
          SELECT 1 FROM information_schema.schemata
          WHERE schema_name = '${e}'
        ) as schema_exists`);if(t[0]?.rows?.[0]?.schema_exists!==!0)return!1;let n=await this.runSQL(`SELECT EXISTS (
          SELECT 1 FROM information_schema.tables
          WHERE table_schema = '${e}' AND table_name IN ('migrations', '_migrations')
        ) as table_exists`);if(n[0]?.rows?.[0]?.table_exists!==!0)return!1;let s=await this.runSQL(`SELECT obj_description(oid, 'pg_namespace') as comment
         FROM pg_namespace
         WHERE nspname = '${e}'`),r=s[0]?.rows?.[0]?.comment;if(!r||!r.includes(i))throw Error(`Legacy installation detected: Schema '${e}' and migrations table exist, but missing stripe-sync comment marker. This may be a legacy installation or manually created schema. Please contact support or manually drop the schema before proceeding.`);if(r.includes(c))return!1;if(r.includes(l))throw Error(`Installation failed: Schema '${e}' exists but installation encountered an error. Comment: ${r}. Please uninstall and install again.`);return!0}catch(e){if(e instanceof Error&&(e.message.includes("Legacy installation detected")||e.message.includes("Installation failed")))throw e;return!1}}async updateInstallationComment(e){let t=e.replace(/'/g,"''");await this.runSQL(`COMMENT ON SCHEMA stripe IS '${t}'`)}async deleteFunction(e){try{await this.api.deleteFunction(this.projectRef,e)}catch(t){console.warn(`Could not delete function ${e}:`,t)}}async deleteSecret(e){try{await this.api.deleteSecrets(this.projectRef,[e])}catch(t){console.warn(`Could not delete secret ${e}:`,t)}}async uninstall(){try{let e=`https://${this.projectRef}.${this.projectBaseUrl}/functions/v1/stripe-setup`,t=await fetch(e,{method:"DELETE",headers:{Authorization:`Bearer ${this.accessToken}`,"Content-Type":"application/json"}});if(!t.ok){let e=await t.text();throw Error(`Uninstall failed: ${t.status} ${e}`)}let n=await t.json();if(!1===n.success)throw Error(`Uninstall failed: ${n.error}`)}catch(e){throw Error(`Uninstall failed: ${e instanceof Error?e.message:String(e)}`)}}injectPackageVersion(e,t){return"latest"===t?e:e.replace(/from ['"]npm:stripe-experiment-sync['"]/g,`from 'npm:stripe-experiment-sync@${t}'`)}async install(e,t,s){let u=e.trim();if(!u.startsWith("sk_")&&!u.startsWith("rk_"))throw Error('Stripe key should start with "sk_" or "rk_"');let h=t||"latest";try{await this.validateProject(),await this.runSQL("CREATE SCHEMA IF NOT EXISTS stripe"),await this.updateInstallationComment(`${i} v${n} ${c}`);let e=this.injectPackageVersion(r,h),t=this.injectPackageVersion(a,h),l=this.injectPackageVersion(o,h);await this.deployFunction("stripe-setup",e,!1),await this.deployFunction("stripe-webhook",t,!1),await this.deployFunction("stripe-worker",l,!1);let d=[{name:"STRIPE_SECRET_KEY",value:u}];this.supabaseManagementUrl&&d.push({name:"MANAGEMENT_API_URL",value:this.supabaseManagementUrl}),await this.setSecrets(d);let g=await this.invokeFunction("stripe-setup",this.accessToken);if(!g.success)throw Error(`Setup failed: ${g.error}`);await this.setupPgCronJob(s),await this.updateInstallationComment(`${i} v${n} ${p}`)}catch(e){throw await this.updateInstallationComment(`${i} v${n} ${l} - ${e instanceof Error?e.message:String(e)}`),e}}};async function h(e){let{supabaseAccessToken:t,supabaseProjectRef:n,stripeKey:s,packageVersion:r,workerIntervalSeconds:a}=e,o=new u({accessToken:t,projectRef:n,projectBaseUrl:e.baseProjectUrl,supabaseManagementUrl:e.supabaseManagementUrl});await o.install(s,r,a)}async function d(e){let{supabaseAccessToken:t,supabaseProjectRef:n}=e,s=new u({accessToken:t,projectRef:n,projectBaseUrl:e.baseProjectUrl,supabaseManagementUrl:e.supabaseManagementUrl});await s.uninstall()}e.s(["INSTALLATION_ERROR_SUFFIX",()=>l,"INSTALLATION_INSTALLED_SUFFIX",()=>p,"INSTALLATION_STARTED_SUFFIX",()=>c,"STRIPE_SCHEMA_COMMENT_PREFIX",()=>i,"SupabaseSetupClient",()=>u,"install",()=>h,"setupFunctionCode",()=>r,"uninstall",()=>d,"webhookFunctionCode",()=>a,"workerFunctionCode",()=>o],465684),e.s([],850264)}]);

//# debugId=7590921c-3e01-65e8-b801-1458af7b9e70
//# sourceMappingURL=89eb68fedaf4cc04.js.map